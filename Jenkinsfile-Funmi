pipeline {
  agent any

  environment {
    AWS_SECRET_ACCESS_KEY = credentials('aws-secret-access-key')
    AWS_ACCESS_KEY_ID     = credentials('aws-access-key-id')
    AWS_REGION           = 'us-east-2'
    AWS_SSH_KEY = credentials('AWS_SSH_KEY')

  }

  parameters {
    choice(name: 'ACTION', choices: ['plan', 'apply', 'destroy'], description: 'Terraform action')
    booleanParam(name: 'BUILD_AMIS', defaultValue: false, description: 'Build base AMI with Packer')
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Build Base AMI') {
      when { expression { params.BUILD_AMIS } }
      steps {
        dir('packer') {
          sh '''
            packer init .
            packer build nginx-app-base.pkr.hcl
          '''
        }
      }
    }

    stage('Terraform Init') {
      steps {
        dir('terraform') {
          sh 'terraform init -reconfigure'
        }
      }
    }

    stage('Terraform Validate') {
      steps {
        dir('terraform') {
          sh 'terraform validate'
        }
      }
    }

    stage('Terraform Plan') {
      when { expression { params.ACTION == 'plan' || params.ACTION == 'apply' } }
      steps {
        dir('terraform') {
          sh 'terraform plan'
        }
      }
    }

    stage('Terraform Apply') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        dir('terraform') {
          sh 'terraform apply -auto-approve'
        }
      }
    }

    stage('Get IPs') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        script {
          dir('terraform') {
            env.BACKEND_IP = sh(
              script: "terraform output -json backend_private_ips | jq -r '.[0]'",
              // script: "terraform output -json backend_public_ips | jq -r '.[0]'",
              returnStdout: true
            ).trim()

            env.WEB_IPS = sh(
              script: "terraform output -json web_server_ips",
              returnStdout: true
            ).trim()
          }

//           env.POSTGRES_ENDPOINT = sh(
//         script: 'terraform output -raw postgres_endpoint',
//     returnStdout: true
// ).trim()

     // echo "Postgres Endpoint: ${env.POSTGRES_ENDPOINT}"
     echo "Backend IP: ${env.BACKEND_IP}"
     echo "Web IPs: ${env.WEB_IPS}"
      }
    } 
    }

    stage('Deploy Nginx + Reverse Proxy') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        script {
          sshagent(credentials: ['AWS_SSH_KEY']) {
          sh """
          for ip in \$(echo '${env.WEB_IPS}' | jq -r '.[]'); do
            echo "Configuring Nginx on \$ip"

            ssh -o StrictHostKeyChecking=no ec2-user@\${ip} << 'EOF'
              rm -rf /tmp/fruits
              git clone https://github.com/ajanakueniola-commits/fruits-veg_market.git /tmp/fruits
              cd fruits-veg_market/frontend
             
              sed -i 's|http://localhost|https://${env.BACKEND_IP}|g' index.html
              sudo cp index.html /usr/share/nginx/html/

              sudo tee /etc/nginx/nginx.conf> /dev/null << EOL
server {
    listen 80;
    server_name enny4life.duckdns.org;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files \\\$uri \\\$uri/ /index.html;
    }

    location /api/ {
        proxy_pass http://${env.BACKEND_IP}:8000/;
        proxy_set_header Host \\\$host;
        proxy_set_header X-Real-IP \\\$remote_addr;
    }
}
EOL

              sudo nginx -t
              sudo systemctl restart nginx
EOF
          done
          """
        }
      }
    }
    }
    stage('Terraform Destroy') {
      when { expression { params.ACTION == 'destroy' } }
      steps {
        dir('terraform') {
          input message: 'Are you sure you want to destroy?', ok: 'Destroy'
          sh 'terraform destroy -auto-approve'
        }
      }
    }

  }

  post {
    success { echo 'Deployment successful ðŸš€' }
    failure { echo 'Pipeline failed âŒ' }
  }
}